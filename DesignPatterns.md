# Design Patterns
Padrões de projeto (Design Patterns): são soluções em nível de design para sanar problemas recorrentes que os desenvolvedores encontram com frequência.

Existem três tipos de Padrões de Projeto:

1. **Padrões Criacionais (Creational Patterns)**
   Padrões usados para a instanciação de classes e objetos. Esses padrões tratam da criação de objetos, ajudando a tornar o sistema independente de como os objetos são instanciados. Eles são usados para controlar a criação de objetos de uma forma que seja adequada para a situação específica.
2. **Padrões Estruturais (Structural Patterns)**
   Os padrões estruturais lidam com a composição de classes e objetos para formar estruturas maiores. Eles ajudam a garantir que, ao combinar objetos, o sistema não se torne muito complexo e que as relações entre os componentes sejam claras e flexíveis.
3. **Padrões Comportamentais (Behavioral Patterns)**
   Esses padrões se concentram na comunicação entre objetos, definindo como os objetos interagem e como as responsabilidades são distribuídas entre eles. Eles ajudam a organizar o fluxo de controle e a comunicação entre objetos em um sistema.

## Os 23 Padrões Clássicos

| Tipo | Padrão | Descrição |
| --- | --- | --- |
| Criacionais | Abstract Factory | Fornece uma interface para criar famílias de objetos relacionados ou dependentes sem especificar suas classes concretas. |
|  | Builder | Separa a construção de um objeto complexo da sua representação, permitindo diferentes representações. |
|  | Factory Method | Define uma interface para criar um objeto, mas permite que as subclasses decidam qual classe instanciar. |
|  | Prototype | Permite a criação de novos objetos a partir de uma instância existente, clonando ou copiando o protótipo. |
|  | Singleton | Garante que uma classe tenha apenas uma instância e fornece um ponto global de acesso a essa instância. |
| Estruturais | Adapter | Permite que objetos com interfaces incompatíveis trabalhem juntos, convertendo a interface de uma classe em outra que o cliente espera. |
|  | Bridge | Desacopla uma abstração da sua implementação, permitindo que ambas variem independentemente. |
|  | Composite | Compõe objetos em estruturas de árvore para representar hierarquias parte-todo, permitindo tratamento uniforme de objetos individuais e composições. |
|  | Decorator | Anexa responsabilidades adicionais a um objeto dinamicamente, proporcionando uma alternativa flexível à subclasse. |
|  | Facade | Fornece uma interface simplificada para um conjunto complexo de classes, abstraindo a complexidade do sistema. |
|  | Flyweight | Usa compartilhamento para suportar grandes quantidades de objetos de forma eficiente em termos de memória. |
|  | Proxy | Fornece um substituto ou marcador de um objeto para controlar o acesso a ele. |

| Tipo | Padrão | Descrição |
| --- | --- | --- |
| Comportamentais | Chain of Responsibility | Evita o acoplamento do remetente de uma solicitação ao seu receptor, ao permitir que vários objetos manipulem a solicitação. |
|  | Command | Encapsula uma solicitação como um objeto, permitindo que você parametrize clientes com diferentes solicitações e suporte operações que podem ser desfeitas. |
|  | Interpreter | Define a gramática de uma linguagem e um interpretador que usa essa gramática para interpretar sentenças na linguagem. |
|  | Iterator | Fornece uma maneira de acessar sequencialmente os elementos de uma coleção sem expor sua representação subjacente. |
|  | Mediator | Define um objeto que encapsula a forma como um conjunto de objetos interage, promovendo o baixo acoplamento. |
|  | Memento | Captura e externaliza o estado interno de um objeto sem violar a encapsulação, permitindo que o objeto seja restaurado a esse estado mais tarde. |
|  | Observer | Define uma dependência um-para-muitos entre objetos, de forma que quando um objeto muda de estado, todos os seus dependentes são notificados e atualizados automaticamente. |
|  | State | Permite que um objeto altere seu comportamento quando seu estado interno muda, parecendo que o objeto mudou de classe. |
|  | Strategy | Define uma família de algoritmos, encapsula cada um deles e os torna intercambiáveis, permitindo que o algoritmo varie independentemente dos clientes que o utilizam. |
|  | Template Method | Define o esqueleto de um algoritmo em uma operação, permitindo que subclasses alterem etapas específicas do algoritmo sem modificar sua estrutura. |
|  | Visitor | Representa uma operação a ser realizada sobre elementos de uma estrutura de objetos, permitindo que você defina uma nova operação sem mudar as classes dos elementos sobre os quais opera. |




## Estudante
- Edson Souza
- [LinkedIn](https://www.linkedin.com/in/edsonfrs/)
- [GitHub](https://github.com/Edsonfrs)

## Entidade
- [DIO - Digital Innovation One] - (https://www.dio.me/sign-up?ref=8EJE9QGVQT)

## Como Usar
1. Clone este repositório.
2. Abra o projeto na IDE ou editor de texto da sua preferência.
3. Execute o projeto.

## Licença
Este projeto está sob a [MIT]. Consulte o arquivo LICENSE para obter mais informações.

